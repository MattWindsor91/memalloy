"C"

include "basic.cat"
include "ftxn.cat"

let fsb = [F]; po
let sbf = po; [F]

(* release sequence *)
let rs = poloc*; rf*

(* conflict *)
let cnf = (((W*M) | (M*W)) & loc) \ id
           
(* synchronises with *)
let sw_ra = ([REL]; fsb?; [A & W]; rs; rf; [R & A]; sbf?; [ACQ]) \ thd
let com = rf | fr | co | co;rf
let tsw = weaklift(com, txn)
let sw = sw_ra | tsw
  
(* happens before *)
let hb = (po | sw)+

let hbl = hb & loc

(* non-atomic reads-from *)
empty (rf ; [NAL]) \ imm([W] ; hbl) as NaRf
				  
(* data race *)
let dr = (cnf \ (A*A)) \ thd \ (hb | hb^-1)
undefined_unless empty dr as Dr 

(* unsequenced race *)
let ur = (cnf & thd) \ (po | po^-1)
undefined_unless empty ur as Ur

(* coherence, etc *)
acyclic hbl | rf | co | fr as HbCom

(* no "if(r==0)" *)
deadness_requires empty if_zero as No_If_Zero 

(* no unsequenced races *)
deadness_requires empty ur as Dead_Ur

(* coherence edges are forced *)
deadness_requires empty unforced_co as Forced_Co

(* external control dependency *)
let cde = ((rf \ thd) | ctrl)* ; ctrl
(* dependable release sequence *)
let drs = rs \ ([R]; !cde)
(* dependable synchronises-with *)
let dsw = sw & (((fsb?; [REL]; drs?) \ (!ctrl; !cde)) ; rf)		 
(* dependable happens-before *)
let dhb = po?; (dsw;ctrl)*
(* self-satisfying cycle *)	    
let ssc = id & cde
(* potential data race *)
let pdr = cnf \ (A*A)
(* reads-from on non-atomic location *)
let narf = rf & (NAL*NAL)

deadness_requires empty pdr \ (dhb | dhb^-1 | narf;ssc | ssc;narf^-1) as Dead_Pdr
        
let scb = fsb?; (po | po;hb;po | hb&sloc | co | fr); sbf?
let scp = (scb & (SC * SC)) \ id        
acyclic scp as Ssimp
