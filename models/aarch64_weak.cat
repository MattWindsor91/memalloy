(*
 * The ARMv8 Application Level Memory Model.
 * Copyright (C) 2016, ARM Ltd.
 *)

"ARM8"

include "basic_H.cat"
include "fr.cat"
      
(* Coherence-after *)
let ca = fr | co

(* Observed-by *)
let rec obs = rfe
        | fre
        | coe \ (co; co)
        | ([W]; obs; [W]; obs; [W]) & ext

(* Per-location coherence requirement *)
acyclic po-loc | ca | rf as coherence

(* Release-happens-before *)
(* let rec rhb = po; [screl]
        | rhb; coi
 *)
let rhb = po; [SCREL]; coi*

(* Locally-happens-before *)
let detour = po-loc & (obs; obs)
(*
let rec lhb = addr
        | data
        | addr; po; [W]
        | (addr | data); rfi
        | ctrl; [W]
        | ctrl; [ISB]; po; [R]
        | [R]; po; [dmb.ld | dmb.full]; po
        | [scacq]; po
        | [R]; rhb
        | rmw
        | lhb; [W]; po; [dmb.st]; po
        | lhb; detour
        | lhb; lhb
 *)
let lhb0 = addr
        | data
        | addr; po; [W]
        | (addr | data); rfi
        | ctrl; [W]
        | (ctrl & isb); [R]
        | [R]; (dmbld | dmb)
        | [SCACQ]; po
        | [R]; rhb
        | atom
let lhb = (lhb0; ([W]; dmbst | detour)*)+
			

(* Happens-before *)
(* let rec hb = rfe
        | lhb
        | hb; hb
 *)
let hb = (rfe | lhb)+
			      
(*
 * Informally, the happens-before relation represents the order in which
 * memory effects are generated by different observers. If a write (A)
 * happens-before a read (B) to the same location then B does not
 * necessarily read-from A, although B cannot be satisfied until A has
 * been generated. Not all reads and writes are required to appear in
 * the happens-before relation.
 *)
irreflexive hb as NoThinAir

(* Acquire-happens-before *)
(*
let rec ahb = rfe; [scacq]
        | rfe; rmw; rf; [scacq]
        | rf; rmw; ahb
 *)
let ahb0 = rfe; [SCACQ]
         | rfe; atom; rf; [SCACQ]
let ahb = (rf; atom)*; ahb0

(* SC-propagates-before *)
(*let rec sc-prop = [W]; po; [dmb.full]; po
        | [W]; rfe; po; [dmb.full]; po
        | [screl]; po; [scacq]
        | [screl]; ahb
        | [screl]; coi; ahb
        | sc-prop; hb
 *)
let sc-prop0 = [W]; dmb
        | [W]; rfe; dmb
        | [SCREL]; po; [SCACQ]
        | [SCREL]; ahb
        | [SCREL]; coi; ahb
let sc-prop = sc-prop0; hb*

(* Store-propagates-before *)
(*let rec st-prop = [W]; po; [dmb.st]; po; [W]
        | st-prop; hb; [W]
        | st-prop; st-prop
 *)
let st-prop0 = [W]; dmbst; [W]
let st-prop = (st-prop0; (hb; [W])*)+
					
(* Release-propagates-before *)
(*let rec rel-prop = [W]; rhb
        | [W]; rfe; rhb
        | rel-prop; rfe; hb & po-loc
        | rel-prop; rel-prop*)
let rel-prop0 = [W]; rhb | [W]; rfe; rhb
let rel-prop = (rel-prop0; (rfe; hb & po-loc)*)+
		 
(* Passes-a-message-to *)
let mp = (rel-prop | st-prop); rfe; hb & po

(*
 * Informally, this constraint captures the non-transitive order between
 * a write that is seen to occur by an observer before a later write
 * ordered by a DMB ST or Store-Release instruction. This ordering
 * allows for a message to be passed from one observer to another,
 * without requiring that the message has been made visible at that
 * point in time to all observers.
 *)
irreflexive mp; obs as Mp

(* Propagates-before *)
(*let rec prop = sc-prop
        | st-prop
        | rel-prop
        | prop; obs
        | prop; prop
 *)
let prop0 = sc-prop
        | st-prop
        | rel-prop
let prop = (prop0; obs*)+
		  
(*
 * Informally, this constraint captures ordered write propagation
 * between all observers such that, if a write (A) propagates-before
 * a read or a write (B), then A will be seen to occur before B by all
 * observers.
 *)
irreflexive prop as Propagation

(* Atomic: Basic LDXR/STXR constraint to forbid intervening writes. *)
empty atom & (fre; coe) as Atomic
